<?xml version="1.0" encoding="UTF-8" ?>
<class xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="DiscordppClient" inherits="RefCounted" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
 The Client class is the main entry point for the Discord SDK. All functionality is exposed through this class.
 See [url=https://discord.com/developers/docs/social-sdk/getting_started.html]this[/url] "Getting Started" for more information on how to use the Client class.

Reference: [url]https://discord.com/developers/docs/social-sdk/classdiscordpp_1_1Client.html[/url]
</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="AbortAuthorize">
			<return type="void" />
			<description>
 This will abort the authorize flow if it is in progress and tear down any associated state.
 NOTE: this *will not* close authorization windows presented to the user.
</description>
		</method>
		<method name="AbortGetTokenFromDevice">
			<return type="void" />
			<description>
 This function is used to abort/cleanup the device authorization flow.
</description>
		</method>
		<method name="AcceptActivityInvite">
			<return type="void" />
			<param index="0" name="invite" type="DiscordppActivityInvite" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Accepts an activity invite that the current user has received.
 The given callback will be invoked with the join secret for the activity, which can be used to join the user to the game's internal party system for example. This join secret comes from the other user's rich presence activity.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, joinSecret: String)
[/codeblock]
</description>
		</method>
		<method name="AcceptDiscordFriendRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Accepts an incoming Discord friend request from the target user.
 Fails if the target user has not sent a Discord friend request to the current user, meaning that the Discord relationship type between the users must be RelationshipType::PendingIncoming.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="AcceptGameFriendRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Accepts an incoming game friend request from the target user.
 Fails if the target user has not sent a game friend request to the current user, meaning that the game relationship type between the users must be RelationshipType::PendingIncoming.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="AddLogCallback">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<param index="1" name="minSeverity" type="int" enum="DiscordppLoggingSeverity.Enum" />
			<description>
 Adds a callback function to be invoked for each new log message generated by the SDK.
 This function explicitly excludes most logs for voice and webrtc activity since those are generally much noisier and you may want to pick a different log level for those. So it will instead include logs for things such as lobbies, relationships, presence, and authentication.
 We strongly recommend invoking this function immediately after constructing the Client object.

Where [param callback] signature is:
[codeblock]
func(message: String, severity: DiscordppLoggingSeverity.Enum)
[/codeblock]
</description>
		</method>
		<method name="AddVoiceLogCallback">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<param index="1" name="minSeverity" type="int" enum="DiscordppLoggingSeverity.Enum" />
			<description>
 Adds a callback function to be invoked for each new log message generated by the voice subsystem of the SDK, including the underlying webrtc infrastructure.
 We strongly recommend invoking this function immediately after constructing the Client object.

Where [param callback] signature is:
[codeblock]
func(message: String, severity: DiscordppLoggingSeverity.Enum)
[/codeblock]
</description>
		</method>
		<method name="Authorize">
			<return type="void" />
			<param index="0" name="args" type="DiscordppAuthorizationArgs" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Initiates an OAuth2 flow for a user to "sign in with Discord". This flow is intended for desktop and mobile devices. If you are implementing for the console, leverage the device auth flow instead (Client::GetTokenFromDevice or Client::OpenAuthorizeDeviceScreen).

 [b]## Overview[/b]
 If you're not familiar with OAuth2, some basic background: At a high level the goal of OAuth2 is to allow a user to connect two applications together and share data between them. In this case, allowing a game to access some of their Discord data. The high level flow is: [br]- This function, Authorize, is invoked to start the OAuth2 process, and the user is sent to Discord [br]- On Discord, the user sees a prompt to authorize the connection, and that prompt explains what data and functionality the game is requesting. [br]- Once the user approves the connection, they are redirected back to your application with a secret code. [br]- You can then exchange that secret code to get back an access token which can be used to authenticate with the SDK.

 [b]## Public vs Confidential Clients[/b]
 Normal OAuth2 requires a backend server to handle exchanging the "code" for a "token" (the last step mentioned above). Not all games have backend servers or their own identity system though, and for early testing of the SDK that can take some time to setup.
 If desired, you can instead change your Discord application in the developer portal (on the OAuth2 tab), to be a "public" client. This will allow you to exchange the code for a token without a backend server, by using the GetToken function below. You can also change this setting back once you have a backend in place later too.

 [b]## Overlay[/b]
 To streamline the authentication process, the SDK will attempt to use the Discord overlay if it is enabled. This will allow the user to authenticate without leaving the game, enabling a more seamless experience.
 You should check to see if the Discord overlay works with your game before shipping. It's ok if it doesn't though, the SDK will fall back to using a browser window. Once you're ready to ship, you can work with us to have the overlay enabled by default for your game too.
 If your game's main window is not the same process that the SDK is running in, then you need to tell the SDK the PID of the window that the overlay should attach to. You can do this by calling Client::SetGameWindowPid.

 [b]## Redirects[/b]
 For the Authorize function to work, you must configure a redirect url in your Discord application in the developer portal, (it is located on the OAuth2 tab). [br]- For desktop applications, add `http://127.0.0.1/callback` [br]- For mobile applications, add `discord-APP_ID:/authorize/callback`
 The SDK will then spin up a local webserver to handle the OAuth2 redirects for you as well to streamline your integration.

 [b]## Security[/b]
 This function accepts an args object, and two of those values are important for security: [br]- To prevent CSRF attacks during auth, the SDK automatically attaches a state and checks it for you when performing the authorization. You can override state if you want for your own flow, but please be mindful to keep it a secure, random value. [br]- If you are using the Client::GetToken function you will need to provide a "code challenge" or "code verifier". We'll spare you the boring details of how that works (woo&#8230; crypto), as we've made a simple function to create these for you, Client::CreateAuthorizationCodeVerifier. That returns a struct with two items, a `challenge` value to pass into this function and a `verifier` value to pass into Client::GetToken.

 [b]## Callbacks &amp; Code Exchange[/b]
 When this flow completes, the given callback function will be invoked with a "code". That code must be exchanged for an actual authorization token before it can be used. To start, you can use the Client::GetToken function to perform this exchange. Longer term private apps will want to move to the server side API for this, since that enables provisional accounts to "upgrade" to full Discord accounts.

 [b]## Android[/b]
 You must add the appropriate intent filter to your `AndroidManifest.xml`. `AndroidBuildPostProcessor` in the sample demonstrates how to do this automatically.
 If you'd like to manage it yourself, the required entry in your `&lt;application&gt;` looks like this: ```xml &lt;activity android:name="com.discord.socialsdk.AuthenticationActivity" android:exported="true"&gt;   &lt;intent-filter&gt;     &lt;action android:name="android.intent.action.VIEW" /&gt;     &lt;category android:name="android.intent.category.DEFAULT" /&gt;     &lt;category android:name="android.intent.category.BROWSABLE" /&gt;     &lt;data android:scheme="discord-1234567890123456789" /&gt;   &lt;/intent-filter&gt; &lt;/activity&gt; ``` Replace the numbers after `discord-` with your Application ID from the Discord developer portal.
 Android support (specifically the builtin auth flow) requires the androidx.browser library as a dependency of your app. The sample uses Google External Dependency Manager to add this to the Gradle build for the project, but you may use any means of your choosing to add this dependency. We currently depend on version 1.8.0 of this library.
 For more information see: https://discord.com/developers/docs/topics/oauth2

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, code: String, redirectUri: String)
[/codeblock]
</description>
		</method>
		<method name="BlockUser">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Blocks the target user so that they cannot send the user friend or activity invites and cannot message them anymore.
 Blocking a user will also remove any existing relationship between the two users, and persists across games, so blocking a user in one game or on Discord will block them in all other games and on Discord as well.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="CanOpenMessageInDiscord">
			<return type="bool" />
			<param index="0" name="messageId" type="int" />
			<description>
 Returns true if the given message is able to be viewed in a Discord client.
 Not all chat messages are replicated to Discord. For example lobby chat and some DMs are ephemeral and not persisted on Discord so cannot be opened. This function checks those conditions and makes sure the message is viewable in Discord.
</description>
		</method>
		<method name="CancelDiscordFriendRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Cancels an outgoing Discord friend request to the target user.
 Fails if a Discord friend request has not been sent to the target user, meaning that the Discord relationship type between the users must be RelationshipType::PendingOutgoing.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="CancelGameFriendRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Cancels an outgoing game friend request to the target user.
 Fails if a game friend request has not been sent to the target user, meaning that the game relationship type between the users must be RelationshipType::PendingOutgoing.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="ClearRichPresence">
			<return type="void" />
			<description>
 Clears the right presence for the current user.
</description>
		</method>
		<method name="CloseAuthorizeDeviceScreen">
			<return type="void" />
			<description>
 This function is used to hide the device authorization screen and is used for the case where the user is on a limited input device, such as a console or smart TV. This function should be used in conjunction with a backend server to handle the device authorization flow. For a public client, you can use Client::AbortGetTokenFromDevice instead.
</description>
		</method>
		<method name="Connect">
			<return type="void" />
			<description>
 Asynchronously connects the client to Discord.
 If a client is disconnecting, this will wait for the disconnect before reconnecting. You should use the Client::SetStatusChangedCallback and Client::GetStatus functions to receive updates on the client status. The Client is only safe to use once the status changes to Status::Ready.
</description>
		</method>
		<method name="CreateAuthorizationCodeVerifier">
			<return type="DiscordppAuthorizationCodeVerifier" />
			<description>
 Helper function that can create a code challenge and verifier for use in the Client::Authorize + Client::GetToken flow. This returns a struct with two items, a `challenge` value to pass into Client::Authorize and a `verifier` value to pass into GetToken.
</description>
		</method>
		<method name="CreateOrJoinLobby">
			<return type="void" />
			<param index="0" name="secret" type="String" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Joins the user to the specified lobby, creating one if it does not exist.
 The lobby is specified by the supplied string, which should be a hard to guess secret generated by the game. All users who join the lobby with the same secret will be placed in the same lobby.
 For exchanging the secret, we strongly encourage looking into the activity invite and rich presence systems which provide a way to include a secret string that only accepted party members are able to see.
 As with server created lobbies, client created lobbies auto-delete once they have been idle for a few minutes (which currently defaults to 5 minutes). A lobby is idle if no users are connected to it.
 This function shouldn't be used for long lived lobbies. The "secret" value expires after ~30 days, at which point the existing lobby cannot be joined and a new one would be created instead.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, lobbyId: int)
[/codeblock]
</description>
		</method>
		<method name="CreateOrJoinLobbyWithMetadata">
			<return type="void" />
			<param index="0" name="secret" type="String" />
			<param index="1" name="lobbyMetadata" type="Dictionary[String, String]" />
			<param index="2" name="memberMetadata" type="Dictionary[String, String]" />
			<param index="3" name="callback" type="Callable" />
			<description>
 Variant of Client::CreateOrJoinLobby that also accepts developer-supplied metadata.
 Metadata is just simple string key/value pairs. An example use case for this might be to the internal game ID of the user of each lobby so all members of the lobby can have a mapping of discord IDs to game IDs. Subsequent calls to CreateOrJoinLobby will overwrite the metadata for the lobby and member.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, lobbyId: int)
[/codeblock]
</description>
		</method>
		<method name="DeleteUserMessage">
			<return type="void" />
			<param index="0" name="recipientId" type="int" />
			<param index="1" name="messageId" type="int" />
			<param index="2" name="cb" type="Callable" />
			<description>
 Deletes the specified message sent by the current user to the specified recipient.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="Disconnect">
			<return type="void" />
			<description>
 Asynchronously disconnects the client.
 You can leverage Client::SetStatusChangedCallback and Client::GetStatus to receive updates on the client status. It is fully disconnected when the status changes to Client::Status::Disconnected.
</description>
		</method>
		<method name="Drop">
			<return type="void" />
			<description>

</description>
		</method>
		<method name="EditUserMessage">
			<return type="void" />
			<param index="0" name="recipientId" type="int" />
			<param index="1" name="messageId" type="int" />
			<param index="2" name="content" type="String" />
			<param index="3" name="cb" type="Callable" />
			<description>
 Edits the specified message sent by the current user to the specified recipient.
 All of the same restrictions apply as for sending a message, see SendUserMessage for more.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="EndCall">
			<return type="void" />
			<param index="0" name="channelId" type="int" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Ends any active call, if any. Any references you have to Call objects are invalid after they are ended, and can be immediately freed.

Where [param callback] signature is:
[codeblock]
func()
[/codeblock]
</description>
		</method>
		<method name="EndCalls">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
 Ends any active call, if any. Any references you have to Call objects are invalid after they are ended, and can be immediately freed.

Where [param callback] signature is:
[codeblock]
func()
[/codeblock]
</description>
		</method>
		<method name="ErrorToString" qualifiers="static">
			<return type="String" />
			<param index="0" name="type" type="int" enum="DiscordppClientError.Enum" />
			<description>
 Converts the Error enum to a string.
</description>
		</method>
		<method name="ExchangeChildToken">
			<return type="void" />
			<param index="0" name="parentApplicationToken" type="String" />
			<param index="1" name="childApplicationId" type="int" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Exchanges a parent application token for a child application token.
 This is used to get a token for a child application that is linked to the parent application. This is only relevant if you have an applications set up in a parent/child relationship, which is applicable if you are a publisher with multiple games under the same account system. Access to this feature is currently limited.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="FetchCurrentUser">
			<return type="void" />
			<param index="0" name="tokenType" type="int" enum="DiscordppAuthorizationTokenType.Enum" />
			<param index="1" name="token" type="String" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Fetches basic information about the user associated with the given auth token.
 This can allow you to check if an auth token is valid or not. This does not require the client to be connected or to have it's own authentication token, so it can be called immediately after the client connects.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, id: int, name: String)
[/codeblock]
</description>
		</method>
		<method name="GetApplicationId">
			<return type="int" />
			<description>
 This function is used to get the application ID for the client. This is used to identify the application to the Discord client. This is used for things like authentication, rich presence, and activity invites when *not* connected with Client::Connect. When calling Client::Connect, the application ID is set automatically
</description>
		</method>
		<method name="GetCall">
			<return type="DiscordppCall" />
			<param index="0" name="channelId" type="int" />
			<description>
 Returns a reference to the currently active call, if any.
</description>
		</method>
		<method name="GetCalls">
			<return type="DiscordppCall[]" />
			<description>
 Returns a reference to all currently active calls, if any.
</description>
		</method>
		<method name="GetChannelHandle">
			<return type="Variant" />
			<param index="0" name="channelId" type="int" />
			<description>
 Returns a reference to the Discord channel object for the given ID.
 All messages in Discord are sent in a channel, so the most common use for this will be to look up the channel a message was sent in. For convience this API will also work with lobbies, so the three possible return values for the SDK are a DM, an Ephemeral DM, and a Lobby.
Returns [DiscordppChannelHandle] or [code]null[/code].
</description>
		</method>
		<method name="GetCurrentInputDevice">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Asynchronously fetches the current audio input device in use by the client.

Where [param cb] signature is:
[codeblock]
func(device: DiscordppAudioDevice)
[/codeblock]
</description>
		</method>
		<method name="GetCurrentOutputDevice">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Asynchronously fetches the current audio output device in use by the client.

Where [param cb] signature is:
[codeblock]
func(device: DiscordppAudioDevice)
[/codeblock]
</description>
		</method>
		<method name="GetCurrentUser">
			<return type="DiscordppUserHandle" />
			<description>
 Returns the user associated with the current client.
 **Must not be called before the Client::GetStatus has changed to Status::Ready.** If the client has disconnected, or is in the process of reconnecting, it will return the previous value of the user, even if the auth token has changed since then. Wait for client.GetStatus() to change to Ready before accessing it again. If accessed before the client is ready, it will return a dummy object.
</description>
		</method>
		<method name="GetCurrentUserV2">
			<return type="Variant" />
			<description>
 Returns the UserHandle associated with the current user, if one is available.
 Unlike GetCurrentUser(), this method returns std::nullopt instead of a dummy object when no user is authenticated or available. This provides clearer intent about when the user data is actually available.
Returns [DiscordppUserHandle] or [code]null[/code].
</description>
		</method>
		<method name="GetDefaultAudioDeviceId" qualifiers="static">
			<return type="String" />
			<description>
 Returns the ID of the system default audio device if the user has not explicitly chosen one.
</description>
		</method>
		<method name="GetDefaultCommunicationScopes" qualifiers="static">
			<return type="String" />
			<description>
 Returns the default set of OAuth2 scopes that should be used with the Discord SDK when making use of the full SDK capabilities, including communications-related features (e.g. user DMs, lobbies, voice chat). If your application does not make use of these features, you should use Client::GetDefaultPresenceScopes instead.
 Communications-related features are currently in limited access and are not available to all applications, however, they can be demoed in limited capacity by all applications. If you are interested in using these features in your game, please reach out to the Discord team.
 It's ok to further customize your requested oauth2 scopes to add additional scopes if you have legitimate usages for them. However, we strongly recommend always using Client::GetDefaultCommunicationScopes or Client::GetDefaultPresenceScopes as a baseline to enable a better authorization experience for users!
</description>
		</method>
		<method name="GetDefaultPresenceScopes" qualifiers="static">
			<return type="String" />
			<description>
 Returns the default set of OAuth2 scopes that should be used with the Discord SDK when leveraging baseline presence-related features (e.g. friends list, rich presence, provisional accounts, activity invites). If your application is using communications-related features, which are currently available in limited access, you should use Client::GetDefaultCommunicationScopes instead.
 It's ok to further customize your requested oauth2 scopes to add additional scopes if you have legitimate usages for them. However, we strongly recommend always using Client::GetDefaultCommunicationScopes or Client::GetDefaultPresenceScopes as a baseline to enable a better authorization experience for users!
</description>
		</method>
		<method name="GetDiscordClientConnectedUser">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="callback" type="Callable" />
			<description>
 If the Discord app is running on the user's computer and the SDK establishes a connection to it, this function will return the user that is currently logged in to the Discord app.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, user: Variant)
[/codeblock]
</description>
		</method>
		<method name="GetGuildChannels">
			<return type="void" />
			<param index="0" name="guildId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Fetches all of the channels that the current user can access in the given guild.
 The purpose of this is to power the channel linking flow for linking a Discord channel to an in-game lobby. So this function can be used to power a UI to let the user pick which channel to link to once they have picked a guild. See the docs on LobbyHandle for more information.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, guildChannels: Array[DiscordppGuildChannel])
[/codeblock]
</description>
		</method>
		<method name="GetInputDevices">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Asynchronously fetches the list of audio input devices available to the user.

Where [param cb] signature is:
[codeblock]
func(devices: Array[DiscordppAudioDevice])
[/codeblock]
</description>
		</method>
		<method name="GetInputVolume">
			<return type="float" />
			<description>
 Returns the input volume for the current user's microphone.
 Input volume is specified as a percentage in the range [0, 100] which represents the perceptual loudness.
</description>
		</method>
		<method name="GetLobbyHandle">
			<return type="Variant" />
			<param index="0" name="lobbyId" type="int" />
			<description>
 Returns a reference to the Discord lobby object for the given ID.
Returns [DiscordppLobbyHandle] or [code]null[/code].
</description>
		</method>
		<method name="GetLobbyIds">
			<return type="int[]" />
			<description>
 Returns a list of all the lobbies that the user is a member of and the SDK has loaded.
 Lobbies are optimistically loaded when the SDK starts but in some cases may not be available immediately after the SDK status changes to Status::Ready.
</description>
		</method>
		<method name="GetLobbyMessagesWithLimit">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="limit" type="int" />
			<param index="2" name="cb" type="Callable" />
			<description>
 Retrieves recent messages from the specified lobby.
 Returns a list of MessageHandle representing the recent messages in the lobby, with a maximum of 200 messages and up to 72 hours. The messages are returned in reverse chronological order (newest first). This function requires the current user to be a member of the lobby.
 Note: This function makes an HTTP request to Discord's API to retrieve messages, as opposed to only returning messages that are cached locally by the SDK.
 Retrieves recent messages from the specified lobby with the specified limit.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, messages: Array[DiscordppMessageHandle])
[/codeblock]
</description>
		</method>
		<method name="GetMessageHandle">
			<return type="Variant" />
			<param index="0" name="messageId" type="int" />
			<description>
 Returns a reference to the Discord message object for the given ID.
 The SDK keeps the 25 most recent messages in each channel in memory. Messages sent before the SDK was started cannot be accessed with this.
Returns [DiscordppMessageHandle] or [code]null[/code].
</description>
		</method>
		<method name="GetOutputDevices">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Asynchronously fetches the list of audio output devices available to the user.

Where [param cb] signature is:
[codeblock]
func(devices: Array[DiscordppAudioDevice])
[/codeblock]
</description>
		</method>
		<method name="GetOutputVolume">
			<return type="float" />
			<description>
 Returns the output volume for the current user.
 Output volume specified as a percentage in the range [0, 200] which represents the perceptual loudness.
</description>
		</method>
		<method name="GetProvisionalToken">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="externalAuthType" type="int" enum="DiscordppAuthenticationExternalAuthType.Enum" />
			<param index="2" name="externalAuthToken" type="String" />
			<param index="3" name="callback" type="Callable" />
			<description>
 Provisional accounts are a way for users that have not signed up for Discord to still access SDK functionality. They are "placeholder" Discord accounts for the user that are owned and managed by your game. Provisional accounts exist so that your users can engage with Discord APIs and systems without the friction of creating their own Discord account. Provisional accounts and their data are unique per Discord application.
 This function generates a Discord access token. You pass in the "identity" of the user, and it generates a new Discord account that is tied to that identity. There are multiple ways of specifying that identity, including using Steam/Epic services, or using your own identity system.
 The callback function will be invoked with an access token that expires in 1 hour. Refresh tokens are not supported for provisional accounts, so that will be an empty string. You will need to call this function again to get a new access token when the old one expires.
 NOTE: When the token expires the SDK will still continue to receive updates such as new messages sent in a lobby, and any voice calls will continue to be active. But any new actions taken will fail such as sending a messaging or adding a friend. You can get a new token and pass it to UpdateToken without interrupting the user's experience.
 It is suggested that these provisional tokens are not stored, and instead to just invoke this function each time the game is launched and when these tokens are about to expire. However, should you choose to store it, it is recommended to differentiate these provisional account tokens from "full" Discord account tokens.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, refreshToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="GetRelationshipHandle">
			<return type="DiscordppRelationshipHandle" />
			<param index="0" name="userId" type="int" />
			<description>
 Returns the RelationshipHandle that corresponds to the relationship between the current user and the given user.
</description>
		</method>
		<method name="GetRelationships">
			<return type="DiscordppRelationshipHandle[]" />
			<description>
 Returns a list of all of the relationships the current user has with others, including all Discord relationships and all Game relationships for the current game.
</description>
		</method>
		<method name="GetRelationshipsByGroup">
			<return type="DiscordppRelationshipHandle[]" />
			<param index="0" name="groupType" type="int" enum="DiscordppRelationshipGroupType.Enum" />
			<description>
 Returns a list of relationships that belong to the specified relationship group type. Relationships are logically partitioned into groups based on online status and game activity: [br]- OnlinePlayingGame: Users who are online and currently playing the game [br]- OnlineElsewhere: Users who are online but not playing the game (users who have played the game before are sorted to the top) [br]- Offline: Users who are offline
</description>
		</method>
		<method name="GetSelfDeafAll">
			<return type="bool" />
			<description>
 Returns whether the current user is deafened in all calls.
</description>
		</method>
		<method name="GetSelfMuteAll">
			<return type="bool" />
			<description>
 Returns whether the current user's microphone is muted in all calls.
</description>
		</method>
		<method name="GetStatus">
			<return type="int" enum="DiscordppClientStatus.Enum" />
			<description>
 Returns the current status of the client, see the Status enum for an explanation of the possible values.
</description>
		</method>
		<method name="GetToken">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="code" type="String" />
			<param index="2" name="codeVerifier" type="String" />
			<param index="3" name="redirectUri" type="String" />
			<param index="4" name="callback" type="Callable" />
			<description>
 Exchanges an authorization code that was returned from the Client::Authorize function for an access token which can be used to authenticate with the SDK.
 The callback function will be invoked with two tokens: [br]- An access token which can be used to authenticate with the SDK, but expires after 7 days. [br]- A refresh token, which cannot be used to authenticate, but can be used to get a new access token later. Refresh tokens do not currently expire.
 It will also include when the access token expires in seconds. You will want to store this value as well and refresh the token when it gets close to expiring (for example if the user launches the game and the token expires within 24 hours, it would be good to refresh it).
 For more information see https://discord.com/developers/docs/topics/oauth2
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, refreshToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="GetTokenFromDevice">
			<return type="void" />
			<param index="0" name="args" type="DiscordppDeviceAuthorizationArgs" />
			<param index="1" name="callback" type="Callable" />
			<description>
 This function is a combination of Client::Authorize and Client::GetToken, but is used for the case where the user is on a limited input device, such as a console or smart TV.
 The callback function will be invoked with two tokens: [br]- An access token which can be used to authenticate with the SDK, but expires after 7 days. [br]- A refresh token, which cannot be used to authenticate, but can be used to get a new access token later. Refresh tokens do not currently expire.
 It will also include when the access token expires in seconds. You will want to store this value as well and refresh the token when it gets close to expiring (for example if the user launches the game and the token expires within 24 hours, it would be good to refresh it).
 For more information see https://discord.com/developers/docs/topics/oauth2
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic. If you have a backend server for auth, you can use Client::OpenAuthorizeDeviceScreen and Client::CloseAuthorizeDeviceScreen to show/hide the UI for the device auth flow.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, refreshToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="GetTokenFromDeviceProvisionalMerge">
			<return type="void" />
			<param index="0" name="args" type="DiscordppDeviceAuthorizationArgs" />
			<param index="1" name="externalAuthType" type="int" enum="DiscordppAuthenticationExternalAuthType.Enum" />
			<param index="2" name="externalAuthToken" type="String" />
			<param index="3" name="callback" type="Callable" />
			<description>
 This function is a combination of Client::Authorize and Client::GetTokenFromProvisionalMerge, but is used for the case where the user is on a limited input device, such as a console or smart TV.
 This function should be used whenever a user with a provisional account wants to link to an existing Discord account or "upgrade" their provisional account into a "full" Discord account.
 In this case, data from the provisional account should be "migrated" to the Discord account, a process we call "account merging". Specifically relationships, DMs, and lobby memberships are transferred to the Discord account.
 The provisional account will be deleted once this merging process completes. If the user later unlinks, then a new provisional account with a new unique ID is created.
 The account merging process starts the same as the normal login flow, by invoking the GetTokenFromDevice. But instead of calling GetTokenFromDevice, call this function and pass in the provisional user's identity as well.
 The Discord backend can then find both the provisional account with that identity and the new Discord account and merge any data as necessary.
 See the documentation for GetTokenFromDevice for more details on the callback. Note that the callback will be invoked when the token exchange completes, but the process of merging accounts happens asynchronously so will not be complete yet.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic. If you have a backend server for auth, you can use Client::OpenAuthorizeDeviceScreen and Client::CloseAuthorizeDeviceScreen to show/hide the UI for the device auth flow.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, refreshToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="GetTokenFromProvisionalMerge">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="code" type="String" />
			<param index="2" name="codeVerifier" type="String" />
			<param index="3" name="redirectUri" type="String" />
			<param index="4" name="externalAuthType" type="int" enum="DiscordppAuthenticationExternalAuthType.Enum" />
			<param index="5" name="externalAuthToken" type="String" />
			<param index="6" name="callback" type="Callable" />
			<description>
 This function should be used with the Client::Authorize function whenever a user with a provisional account wants to link to an existing Discord account or "upgrade" their provisional account into a "full" Discord account.
 In this case, data from the provisional account should be "migrated" to the Discord account, a process we call "account merging". Specifically relationships, DMs, and lobby memberships are transferred to the Discord account.
 The provisional account will be deleted once this merging process completes. If the user later unlinks, then a new provisional account with a new unique ID is created.
 The account merging process starts the same as the normal login flow, by invoking the Authorize method to get an authorization code back. But instead of calling GetToken, call this function and pass in the provisional user's identity as well.
 The Discord backend can then find both the provisional account with that identity and the new Discord account and merge any data as necessary.
 See the documentation for GetToken for more details on the callback. Note that the callback will be invoked when the token exchange completes, but the process of merging accounts happens asynchronously so will not be complete yet.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, refreshToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="GetUser">
			<return type="Variant" />
			<param index="0" name="userId" type="int" />
			<description>
 Returns the UserHandle associated with the given user ID.
 It will not fetch a user from Discord's API if it is not available. Generally you can trust that users will be available for all relationships and for the authors of any messages received.
Returns [DiscordppUserHandle] or [code]null[/code].
</description>
		</method>
		<method name="GetUserGuilds">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Fetches all of the guilds (also known as Discord servers) that the current user is a member of.
 The purpose of this is to power the channel linking flow for linking a Discord channel to an in-game lobby. So this function can be used to power a UI to let the user which guild to link to. See the docs on LobbyHandle for more information.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, guilds: Array[DiscordppGuildMinimal])
[/codeblock]
</description>
		</method>
		<method name="GetUserMessageSummaries">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Retrieves message conversation summaries for all users the current user has DM conversations with.
 The callback will be invoked with a list of UserMessageSummary objects containing: [br]- userId: The ID of the user this conversation is with [br]- lastMessageId: The ID of the most recent message in this conversation

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, summaries: Array[DiscordppUserMessageSummary])
[/codeblock]
</description>
		</method>
		<method name="GetUserMessagesWithLimit">
			<return type="void" />
			<param index="0" name="recipientId" type="int" />
			<param index="1" name="limit" type="int" />
			<param index="2" name="cb" type="Callable" />
			<description>
 Retrieves messages from the DM conversation with the specified user.
 Returns a list of MessageHandle representing the recent messages in the conversation with the recipient, with a maximum number specified by the limit parameter. The messages are returned in reverse chronological order (newest first). This function checks the local cache first and only makes an HTTP request to Discord's API if there are not enough cached messages available.
 If limit is greater than 0, restricts the number of messages returned. If limit is 0 or negative, the limit parameter is omitted from the request. This is intended for games to load message history when users open a DM conversation.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, messages: Array[DiscordppMessageHandle])
[/codeblock]
</description>
		</method>
		<method name="GetVersionHash" qualifiers="static">
			<return type="String" />
			<description>
 Returns the git commit hash this version was built from.
</description>
		</method>
		<method name="GetVersionMajor" qualifiers="static">
			<return type="int" />
			<description>
 Returns the major version of the Discord Social SDK.
</description>
		</method>
		<method name="GetVersionMinor" qualifiers="static">
			<return type="int" />
			<description>
 Returns the minor version of the Discord Social SDK.
</description>
		</method>
		<method name="GetVersionPatch" qualifiers="static">
			<return type="int" />
			<description>
 Returns the patch version of the Discord Social SDK.
</description>
		</method>
		<method name="IsAuthenticated">
			<return type="bool" />
			<description>
 Returns true if the SDK has a non-empty OAuth2 token set, regardless of whether that token is valid or not.
</description>
		</method>
		<method name="JoinLinkedLobbyGuild">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="provisionalUserMergeRequiredCallback" type="Callable" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Invites the current user to the Discord guild of the channel that is linked to the specified lobby. The user is forwarded to the Discord client with the resulting invite url, upon which the user can decide to accept or decline that invite.
 On console platforms, the user is not navigated to any Discord client, so the invite url should be presented to the user in some way, so they can use it.

Where [param provisionalUserMergeRequiredCallback] signature is:
[codeblock]
func()
[/codeblock]

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, inviteUrl: String)
[/codeblock]
</description>
		</method>
		<method name="LeaveLobby">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Removes the current user from the specified lobby.
 Only lobbies that contain a "secret" can be left. In other words, only lobbies created with Client::CreateOrJoinLobby can be left. Lobbies created using the server API may not be manipulated by clients, so you must use the server API to remove them too.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="LinkChannelToLobby">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="channelId" type="int" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Links the specified channel on Discord to the specified in-game lobby.
 Any message sent in one will be copied over to the other! See the docs on LobbyHandle for more information.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="OpenAuthorizeDeviceScreen">
			<return type="void" />
			<param index="0" name="clientId" type="int" />
			<param index="1" name="userCode" type="String" />
			<description>
 This function is used to show the device authorization screen and is used for the case where the user is on a limited input device, such as a console or smart TV. This function should be used in conjunction with a backend server to handle the device authorization flow. For a public client, you can use Client::GetTokenFromDevice instead.
</description>
		</method>
		<method name="OpenConnectedGamesSettingsInDiscord">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
 Opens the Connected Games settings in the Discord client, which is where users can manage their settings related to games using the Discord Social SDK.
 If the client isn't connected or the user is a provisional account, this function does nothing.
 It is always a no-op for console platforms.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="OpenMessageInDiscord">
			<return type="void" />
			<param index="0" name="messageId" type="int" />
			<param index="1" name="provisionalUserMergeRequiredCallback" type="Callable" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Opens the given message in the Discord client.
 This is useful when a message is sent that contains content that cannot be viewed in Discord. You can call this function in the click handler for any CTA you show to view the message in Discord.

Where [param provisionalUserMergeRequiredCallback] signature is:
[codeblock]
func()
[/codeblock]

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="ProvisionalUserMergeCompleted">
			<return type="void" />
			<param index="0" name="success" type="bool" />
			<description>
 Some functions don't work for provisional accounts, and require the user merge their account into a full Discord account before proceeding. This callback is invoked when an account merge must take place before proceeding. The developer is responsible for initiating the account merge, and then calling Client::ProvisionalUserMergeCompleted to signal to the SDK that the pending operation can continue with the new account.
</description>
		</method>
		<method name="RefreshToken">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="refreshToken" type="String" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Generates a new access token for the current user from a refresh token.
 Once this is called, the old access and refresh tokens are both invalidated and cannot be used again. The callback function will be invoked with a new access and refresh token. See GetToken for more details.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult, accessToken: String, refreshToken: String, tokenType: DiscordppAuthorizationTokenType.Enum, expiresIn: int, scopes: String)
[/codeblock]
</description>
		</method>
		<method name="RegisterLaunchCommand">
			<return type="bool" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="command" type="String" />
			<description>
 When a user accepts an activity invite for your game within the Discord client, Discord needs to know how to launch the game for that user. This function allows you to register a command that Discord will run to launch your game. You should invoke this when the SDK starts up so that if the user in the future tries to join from Discord the game will be able to be launched for them. Returns true if the command was successfully registered, false otherwise.
 On Windows and Linux, this command should be a path to an executable. It also supports any launch parameters that may be needed, like "C:\path\to my\game.exe" --full-screen --no-hax If you pass an empty string in for the command, the SDK will register the current running executable. To launch the game from a custom protocol like my-awesome-game://, pass that in as an argument of the executable that should be launched by that protocol. For example, "C:\path\to my\game.exe" my-awesome-game://
 On macOS, due to the way Discord registers executables, your game needs to be bundled for this command to work. That means it should be a .app. You can pass a custom protocol like my-awesome-game:// as the custom command, but *not* a path to an executable. If you pass an empty string in for the command, the SDK will register the current running bundle, if any.
</description>
		</method>
		<method name="RegisterLaunchSteamApplication">
			<return type="bool" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="steamAppId" type="int" />
			<description>
 When a user accepts an activity invite for your game within the Discord client, Discord needs to know how to launch the game for that user. For steam games, this function allows you to indicate to Discord what the steam game ID is. You should invoke this when the SDK starts up so that if the user in the future tries to join from Discord the game will be able to be launched for them. Returns true if the command was successfully registered, false otherwise.
</description>
		</method>
		<method name="RejectDiscordFriendRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Declines an incoming Discord friend request from the target user.
 Fails if the target user has not sent a Discord friend request to the current user, meaning that the Discord relationship type between the users must be RelationshipType::PendingIncoming.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="RejectGameFriendRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Declines an incoming game friend request from the target user.
 Fails if the target user has not sent a game friend request to the current user, meaning that the game relationship type between the users must be RelationshipType::PendingIncoming.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="RemoveDiscordAndGameFriend">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Removes any friendship between the current user and the target user. This function will remove BOTH any Discord friendship and any game friendship between the users.
 Fails if the target user is not currently a Discord OR game friend with the current user.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="RemoveGameFriend">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Removes any game friendship between the current user and the target user.
 Fails if the target user is not currently a game friend with the current user.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="RevokeToken">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="token" type="String" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Revoke all application access/refresh tokens associated with a user with any valid access/refresh token. This will invalidate all tokens and they cannot be used again. This is useful if you want to log the user out of the game and invalidate their session.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SearchFriendsByUsername">
			<return type="DiscordppUserHandle[]" />
			<param index="0" name="searchStr" type="String" />
			<description>
 Searches all of your friends by both username and display name, returning a list of all friends that match the search string.
 Under the hood uses the Levenshtein distance algorithm.
</description>
		</method>
		<method name="SendActivityInvite">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="content" type="String" />
			<param index="2" name="cb" type="Callable" />
			<description>
 Sends a Discord activity invite to the specified user.
 The invite is sent as a message on Discord, which means it can be sent in the following situations: [br]- Both users are online and in the game and have not blocked each other [br]- Both users are friends with each other [br]- Both users share a mutual Discord server and have previously DM'd each other on Discord
 You can optionally include some message content to include in the message containing the invite, but it's ok to pass an empty string too.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendActivityJoinRequest">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Requests to join the activity of the specified user.
 This can be called whenever the target user has a rich presence activity for the current game and that activity has space for another user to join them.
 That user will basically receive an activity invite which they can accept or reject.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendActivityJoinRequestReply">
			<return type="void" />
			<param index="0" name="invite" type="DiscordppActivityInvite" />
			<param index="1" name="cb" type="Callable" />
			<description>
 When another user requests to join the current user's party, this function is called to to allow that user to join. Specifically this will send the original user an activity invite which they then need to accept again.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendDiscordFriendRequest">
			<return type="void" />
			<param index="0" name="username" type="String" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Sends a Discord friend request to the target user.
 The target user is identified by their Discord unique username (not their DisplayName).
 After the friend request is sent, each user will have a new Discord relationship created. For the current user the RelationshipHandle::DiscordRelationshipType will be RelationshipType::PendingOutgoing and for the target user it will be RelationshipType::PendingIncoming.
 If the current user already has received a Discord friend request from the target user (meaning RelationshipHandle::DiscordRelationshipType is RelationshipType::PendingIncoming), then the two users will become Discord friends.
 See RelationshipHandle for more information on the difference between Discord and Game relationships.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendDiscordFriendRequestById">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Sends a Discord friend request to the target user.
 The target user is identified by their Discord ID.
 After the friend request is sent, each user will have a new Discord relationship created. For the current user the RelationshipHandle::DiscordRelationshipType will be RelationshipType::PendingOutgoing and for the target user it will be RelationshipType::PendingIncoming.
 If the current user already has received a Discord friend request from the target user (meaning RelationshipHandle::DiscordRelationshipType is RelationshipType::PendingIncoming), then the two users will become Discord friends.
 See RelationshipHandle for more information on the difference between Discord and Game relationships.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendGameFriendRequest">
			<return type="void" />
			<param index="0" name="username" type="String" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Sends (or accepts) a game friend request to the target user.
 The target user is identified by their Discord unique username (not their DisplayName).
 After the friend request is sent, each user will have a new game relationship created. For the current user the RelationshipHandle::GameRelationshipType will be RelationshipType::PendingOutgoing and for the target user it will be RelationshipType::PendingIncoming.
 If the current user already has received a game friend request from the target user (meaning RelationshipHandle::GameRelationshipType is RelationshipType::PendingIncoming), then the two users will become game friends.
 See RelationshipHandle for more information on the difference between Discord and Game relationships.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendGameFriendRequestById">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Sends (or accepts) a game friend request to the target user.
 The target user is identified by their Discord ID.
 After the friend request is sent, each user will have a new game relationship created. For the current user the RelationshipHandle::GameRelationshipType will be RelationshipType::PendingOutgoing and for the target user it will be RelationshipType::PendingIncoming.
 If the current user already has received a game friend request from the target user (meaning RelationshipHandle::GameRelationshipType is RelationshipType::PendingIncoming), then the two users will become game friends.
 See RelationshipHandle for more information on the difference between Discord and Game relationships.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SendLobbyMessage">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="content" type="String" />
			<param index="2" name="cb" type="Callable" />
			<description>
 Sends a message in a lobby chat to all members of the lobby.
 The content of the message is restricted to 2,000 characters maximum. See https://discord.com/developers/docs/resources/message for more details.
 The content of the message can also contain special markup for formatting if desired, see https://discord.com/developers/docs/reference#message-formatting for more details.
 If the lobby is linked to a channel, the message will also be sent to that channel on Discord.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, messageId: int)
[/codeblock]
</description>
		</method>
		<method name="SendLobbyMessageWithMetadata">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="content" type="String" />
			<param index="2" name="metadata" type="Dictionary[String, String]" />
			<param index="3" name="cb" type="Callable" />
			<description>
 Variant of Client::SendLobbyMessage that also accepts metadata to be sent with the message.
 Metadata is just simple string key/value pairs. An example use case for this might be to include the name of the character that sent a message.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, messageId: int)
[/codeblock]
</description>
		</method>
		<method name="SendUserMessage">
			<return type="void" />
			<param index="0" name="recipientId" type="int" />
			<param index="1" name="content" type="String" />
			<param index="2" name="cb" type="Callable" />
			<description>
 Sends a direct message to the specified user.
 The content of the message is restricted to 2,000 characters maximum. See https://discord.com/developers/docs/resources/message for more details.
 The content of the message can also contain special markup for formatting if desired, see https://discord.com/developers/docs/reference#message-formatting for more details.
 A message can be sent between two users in the following situations: [br]- Both users are online and in the game and have not blocked each other [br]- Both users are friends with each other [br]- Both users share a mutual Discord server and have previously DM'd each other on Discord

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, messageId: int)
[/codeblock]
</description>
		</method>
		<method name="SendUserMessageWithMetadata">
			<return type="void" />
			<param index="0" name="recipientId" type="int" />
			<param index="1" name="content" type="String" />
			<param index="2" name="metadata" type="Dictionary[String, String]" />
			<param index="3" name="cb" type="Callable" />
			<description>
 Variant of Client::SendUserMessage that also accepts metadata to be sent with the message.
 Metadata is just simple string key/value pairs. An example use case for this might be to include the name of the character that sent a message.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult, messageId: int)
[/codeblock]
</description>
		</method>
		<method name="SetActivityInviteCreatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function that is invoked when the current user receives an activity invite from another user.
 These invites are always sent as messages, so the SDK is parsing these messages to look for invites and invokes this callback instead. The message create callback will not be invoked for these messages. The invite object contains all the necessary information to identity the invite, which you can later pass to Client::AcceptActivityInvite.

Where [param cb] signature is:
[codeblock]
func(invite: DiscordppActivityInvite)
[/codeblock]
</description>
		</method>
		<method name="SetActivityInviteUpdatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function that is invoked when an existing activity invite changes. Currently, the only thing that changes on an activity invite is its validity. If the sender goes offline or exits the party the receiver was invited to, the invite is no longer joinable. It is possible for an invalid invite to go from invalid to valid if the sender rejoins the activity.

Where [param cb] signature is:
[codeblock]
func(invite: DiscordppActivityInvite)
[/codeblock]
</description>
		</method>
		<method name="SetActivityJoinCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function that is invoked when the current user also has Discord running on their computer and they accept an activity invite in the Discord client.
 This callback is invoked with the join secret from the activity rich presence, which you can use to join them to the game's internal party system. See Activity for more information on invites.

Where [param cb] signature is:
[codeblock]
func(joinSecret: String)
[/codeblock]
</description>
		</method>
		<method name="SetActivityJoinWithApplicationCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function that is invoked when the current user also has Discord running on their computer and they accept an activity invite in the Discord client.
 This callback is invoked with the join secret from the activity rich presence, which you can use to join them to the game's internal party system. See Activity for more information on invites.

Where [param cb] signature is:
[codeblock]
func(applicationId: int, joinSecret: String)
[/codeblock]
</description>
		</method>
		<method name="SetAecDump">
			<return type="void" />
			<param index="0" name="on" type="bool" />
			<description>
 Enables or disables AEC diagnostic recording.
 Used to diagnose issues with acoustic echo cancellation. The input and output waveform data will be written to the log directory.
</description>
		</method>
		<method name="SetApplicationId">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<description>
 This function is used to set the application ID for the client. This is used to identify the application to the Discord client. This is used for things like authentication, rich presence, and activity invites when *not* connected with Client::Connect. When calling Client::Connect, the application ID is set automatically
</description>
		</method>
		<method name="SetAuthorizeDeviceScreenClosedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function to be invoked when the device authorization screen is closed.

Where [param cb] signature is:
[codeblock]
func()
[/codeblock]
</description>
		</method>
		<method name="SetAutomaticGainControl">
			<return type="void" />
			<param index="0" name="on" type="bool" />
			<description>
 When enabled, automatically adjusts the microphone volume to keep it clear and consistent.
 Defaults to on.
 Generally this shouldn't need to be used unless you are building a voice settings UI for the user to control, similar to Discord's voice settings.
</description>
		</method>
		<method name="SetDeviceChangeCallback">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
 Sets a callback function to be invoked when Discord detects a change in the available audio devices.

Where [param callback] signature is:
[codeblock]
func(inputDevices: Array[DiscordppAudioDevice], outputDevices: Array[DiscordppAudioDevice])
[/codeblock]
</description>
		</method>
		<method name="SetEchoCancellation">
			<return type="void" />
			<param index="0" name="on" type="bool" />
			<description>
 Enables or disables the basic echo cancellation provided by the WebRTC library.
 Defaults to on.
 Generally this shouldn't need to be used unless you are building a voice settings UI for the user to control, similar to Discord's voice settings.
</description>
		</method>
		<method name="SetEngineManagedAudioSession">
			<return type="void" />
			<param index="0" name="isEngineManaged" type="bool" />
			<description>
 On mobile devices, set whether the audio environment is managed by the engine or the SDK. On Android, this entails AudioManager state and on iOS, this entails AVAudioSession activation.
 This method must be called before connecting to any Calls if the application manages audio on its own, otherwise audio management will be ended by the voice engine when the last Call is ended.
 The Unity plugin automatically calls this method if the native Unity audio engine is enabled in the project settings.
</description>
		</method>
		<method name="SetGameWindowPid">
			<return type="void" />
			<param index="0" name="pid" type="int" />
			<description>
 When users are linking their account with Discord, which involves an OAuth2 flow, the SDK can streamline it by using Discord's overlay so the interaction happens entirely in-game. If your game's main window is not the same process as the one running the integration you may need to set the window PID using this method. It defaults to the current pid.
</description>
		</method>
		<method name="SetHttpRequestTimeout">
			<return type="void" />
			<param index="0" name="httpTimeoutInMilliseconds" type="int" />
			<description>
 This function is used to override the default HTTP timeout for the websocket client.
</description>
		</method>
		<method name="SetInputDevice">
			<return type="void" />
			<param index="0" name="deviceId" type="String" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Asynchronously changes the audio input device in use by the client to the specified device. You can find the list of device IDs that can be passed in with the Client::GetInputDevices function.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SetInputVolume">
			<return type="void" />
			<param index="0" name="inputVolume" type="float" />
			<description>
 Sets the microphone volume for the current user.
 Input volume is specified as a percentage in the range [0, 100] which represents the perceptual loudness.
</description>
		</method>
		<method name="SetLobbyCreatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked when a lobby "becomes available" to the client.
 A lobby can become available in a few situations: [br]- A new lobby is created and the current user is a member of it [br]- The current user is added to an existing lobby [br]- A lobby recovers after a backend crash and is available once again
 This means that the LobbyCreated callback can be invoked more than once in a single session! Generally though it should never be invoked twice in a row. For example if a lobby crashes or a user is removed from the lobby, you should expect to have the LobbyDeleted callback invoked first.

Where [param cb] signature is:
[codeblock]
func(lobbyId: int)
[/codeblock]
</description>
		</method>
		<method name="SetLobbyDeletedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked when a lobby is no longer available.
 This callback can be invoked in a number of situations: [br]- A lobby the user is a member of is deleted [br]- The current user is removed from a lobby [br]- There is a backend crash that causes the lobby to be unavailable for all users
 This means that this callback might be invoked even though the lobby still exists for other users!

Where [param cb] signature is:
[codeblock]
func(lobbyId: int)
[/codeblock]
</description>
		</method>
		<method name="SetLobbyMemberAddedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function to be invoked whenever a user is added to a lobby.
 This callback will not be invoked when the current user is added to a lobby, instead the LobbyCreated callback will be invoked. Additionally, the SDK separates membership in a lobby from whether a user is connected to a lobby. So a user being added does not necessarily mean they are online and in the lobby at that moment, just that they have permission to connect to that lobby.

Where [param cb] signature is:
[codeblock]
func(lobbyId: int, memberId: int)
[/codeblock]
</description>
		</method>
		<method name="SetLobbyMemberRemovedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function to be invoked whenever a member of a lobby is removed and can no longer connect to it.
 This callback will not be invoked when the current user is removed from a lobby, instead LobbyDeleted callback will be invoked. Additionally this is not invoked when a user simply exits the game. That would cause the LobbyMemberUpdatedCallback to be invoked, and the LobbyMemberHandle object will indicate they are not connected now.

Where [param cb] signature is:
[codeblock]
func(lobbyId: int, memberId: int)
[/codeblock]
</description>
		</method>
		<method name="SetLobbyMemberUpdatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function to be invoked whenever a member of a lobby is changed.
 This is invoked when: [br]- The user connects or disconnects [br]- The metadata of the member is changed

Where [param cb] signature is:
[codeblock]
func(lobbyId: int, memberId: int)
[/codeblock]
</description>
		</method>
		<method name="SetLobbyUpdatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked when a lobby is edited, for example if the lobby's metadata is changed.

Where [param cb] signature is:
[codeblock]
func(lobbyId: int)
[/codeblock]
</description>
		</method>
		<method name="SetLogDir">
			<return type="bool" />
			<param index="0" name="path" type="String" />
			<param index="1" name="minSeverity" type="int" enum="DiscordppLoggingSeverity.Enum" />
			<description>
 Causes logs generated by the SDK to be written to disk in the specified directory.
 This function explicitly excludes most logs for voice and webrtc activity since those are generally much noisier and you may want to pick a different log level for those. So it will instead include logs for things such as lobbies, relationships, presence, and authentication. An empty path defaults to logging alongside the client library. A minSeverity = LoggingSeverity::None disables logging to a file (also the current default). The logs will be placed into a file called "discord.log" in the specified directory. Overwrites any existing discord.log file.
 We strongly recommend invoking this function immediately after constructing the Client object.
 Returns true if the log file was successfully opened, false otherwise.
</description>
		</method>
		<method name="SetMessageCreatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked whenever a new message is received in either a lobby or a DM.
 From the messageId you can fetch the MessageHandle and then the ChannelHandle to determine the location the message was sent as well.
 If the user has the Discord desktop application open on the same machine as the game, then they will hear notifications from the Discord application, even though they are able to see those messages in game. So to avoid double-notifying users, you should call Client::SetShowingChat whenever the chat is shown or hidden to suppress those duplicate notifications.

Where [param cb] signature is:
[codeblock]
func(messageId: int)
[/codeblock]
</description>
		</method>
		<method name="SetMessageDeletedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked whenever a message is deleted.
 Some messages sent from in game, as well as all messages sent from a connected user's Discord client can be edited and deleted in the Discord client. So it is valuable to implement support for this callback so that if a user edits or deletes a message in the Discord client, it is reflected in game as well.

Where [param cb] signature is:
[codeblock]
func(messageId: int, channelId: int)
[/codeblock]
</description>
		</method>
		<method name="SetMessageUpdatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked whenever a message is edited.
 Some messages sent from in game, as well as all messages sent from a connected user's Discord client can be edited and deleted in the Discord client. So it is valuable to implement support for this callback so that if a user edits or deletes a message in the Discord client, it is reflected in game as well.

Where [param cb] signature is:
[codeblock]
func(messageId: int)
[/codeblock]
</description>
		</method>
		<method name="SetNoAudioInputCallback">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
 Callback function invoked when the above threshold is set and there is a change in whether audio is being detected.

Where [param callback] signature is:
[codeblock]
func(inputDetected: bool)
[/codeblock]
</description>
		</method>
		<method name="SetNoAudioInputThreshold">
			<return type="void" />
			<param index="0" name="dBFSThreshold" type="float" />
			<description>
 Threshold that can be set to indicate when no audio is being received by the user's mic.
 An example of when this may be useful: When push to talk is being used and the user pushes their talk key, but something is configured wrong and no audio is being received, this threshold and callback can be used to detect that situation and notify the user. The threshold is specified in DBFS, or decibels relative to full scale, and the range is [-100.0, 100.0] It defaults to -100.0, so is disabled.
</description>
		</method>
		<method name="SetNoiseSuppression">
			<return type="void" />
			<param index="0" name="on" type="bool" />
			<description>
 Enables basic background noise suppression.
 Defaults to on.
 Generally this shouldn't need to be used unless you are building a voice settings UI for the user to control, similar to Discord's voice settings.
</description>
		</method>
		<method name="SetOnlineStatus">
			<return type="void" />
			<param index="0" name="status" type="int" enum="DiscordppStatusType.Enum" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Sets whether a user is online/invisible/idle/dnd on Discord.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SetOpusHardwareCoding">
			<return type="void" />
			<param index="0" name="encode" type="bool" />
			<param index="1" name="decode" type="bool" />
			<description>
 Enables or disables hardware encoding and decoding for audio, if it is available.
 Defaults to on.
 This must be called immediately after constructing the Client. If called too late an error will be logged and the setting will not take effect.
</description>
		</method>
		<method name="SetOutputDevice">
			<return type="void" />
			<param index="0" name="deviceId" type="String" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Asynchronously changes the audio output device in use by the client to the specified device. You can find the list of device IDs that can be passed in with the Client::GetOutputDevices function.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="SetOutputVolume">
			<return type="void" />
			<param index="0" name="outputVolume" type="float" />
			<description>
 Sets the speaker volume for the current user.
 Output volume specified as a percentage in the range [0, 200] which represents the perceptual loudness.
</description>
		</method>
		<method name="SetRelationshipCreatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked whenever a relationship for this user is established or changes type.
 This can be invoked when a user sends or accepts a friend invite or blocks a user for example.

Where [param cb] signature is:
[codeblock]
func(userId: int, isDiscordRelationshipUpdate: bool)
[/codeblock]
</description>
		</method>
		<method name="SetRelationshipDeletedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback to be invoked whenever a relationship for this user is removed, such as when the user rejects a friend request or removes a friend.
 When a relationship is removed, Client::GetRelationshipHandle will return a relationship with the type set to RelationshipType::None.

Where [param cb] signature is:
[codeblock]
func(userId: int, isDiscordRelationshipUpdate: bool)
[/codeblock]
</description>
		</method>
		<method name="SetRelationshipGroupsUpdatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 The RelationshipGroupsUpdatedCallback is invoked whenever any user in the friends list changes. This is intended to be the callback used to ensure the friends list is kept fresh. This can be used in tandem with Client::GetRelationshipsByGroup to build and update the friends list.

Where [param cb] signature is:
[codeblock]
func(userId: int)
[/codeblock]
</description>
		</method>
		<method name="SetSelfDeafAll">
			<return type="void" />
			<param index="0" name="deaf" type="bool" />
			<description>
 Mutes all audio from the currently active call for the current user in all calls. They will not be able to hear any other participants, and no other participants will be able to hear the current user either. Note: This overrides the per-call setting.
</description>
		</method>
		<method name="SetSelfMuteAll">
			<return type="void" />
			<param index="0" name="mute" type="bool" />
			<description>
 Mutes the current user's microphone so that no other participant in their active calls can hear them in all calls. Note: This overrides the per-call setting.
</description>
		</method>
		<method name="SetShowingChat">
			<return type="void" />
			<param index="0" name="showingChat" type="bool" />
			<description>
 Sets whether chat messages are currently being shown in the game.
 If the user has the Discord desktop application open on the same machine as the game, then they will hear notifications from the Discord application, even though they are able to see those messages in game. So to avoid double-notifying users, you can call this function whenever the chat is shown or hidden to suppress those duplicate notifications.
 Keep in mind, if the game stops showing chat for a period of time, or the game loses focus because the user switches to a different app, it is important to call this function again so that the user's notifications get re-enabled in Discord during this time.
</description>
		</method>
		<method name="SetSpeakerMode">
			<return type="bool" />
			<param index="0" name="speakerMode" type="bool" />
			<description>

</description>
		</method>
		<method name="SetStatusChangedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Sets a callback function to be invoked whenever the SDKs status changes.

Where [param cb] signature is:
[codeblock]
func(status: DiscordppClientStatus.Enum, error: DiscordppClientError.Enum, errorDetail: int)
[/codeblock]
</description>
		</method>
		<method name="SetThreadPriority">
			<return type="void" />
			<param index="0" name="thread" type="int" enum="DiscordppClientThread.Enum" />
			<param index="1" name="priority" type="int" />
			<description>
 Allows setting the priority of various SDK threads.
 The threads that can be controlled are: [br]- Client: This is the main thread for the SDK where most of the data processing happens [br]- Network: This is the thread that receives voice data from lobby calls [br]- Voice: This is the thread that the voice engine runs on and processes all audio data
</description>
		</method>
		<method name="SetTokenExpirationCallback">
			<return type="void" />
			<param index="0" name="callback" type="Callable" />
			<description>
 Get a notification when the current token is about to expire or expired.
 This callback is invoked when the SDK detects that the last token passed to Client::UpdateToken is nearing expiration or has expired. This is a signal to the developer to refresh the token. The callback is invoked once per token, and will not be invoked again until a new token is passed to Client::UpdateToken.
 If the token is refreshed before the expiration callback is invoked, call Client::UpdateToken to pass in the new token and reconfigure the token expiration.
 If your client is disconnected (the token was expired when connecting or was revoked while connected), the expiration callback will not be invoked.

Where [param callback] signature is:
[codeblock]
func()
[/codeblock]
</description>
		</method>
		<method name="SetUserUpdatedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 The UserUpdatedCallback is invoked whenever *any* user the current session knows about changes, not just if the current user changes. For example if one of your Discord friends changes their name or avatar the UserUpdatedCallback will be invoked. It is also invoked when users come online, go offline, or start playing your game.

Where [param cb] signature is:
[codeblock]
func(userId: int)
[/codeblock]
</description>
		</method>
		<method name="SetVoiceLogDir">
			<return type="void" />
			<param index="0" name="path" type="String" />
			<param index="1" name="minSeverity" type="int" enum="DiscordppLoggingSeverity.Enum" />
			<description>
 Causes logs generated by the voice subsystem of the SDK to be written to disk in the specified directory.
 These logs will be in a file like discord-webrtc_0, and if they grow to big will be rotated and the number incremented. If the log files already exist the old ones will be renamed to discord-last-webrtc_0.
 An empty path defaults to logging alongside the client library. A minSeverity = LoggingSeverity::None disables logging to a file (also the current default).
 WARNING: This function MUST be invoked immediately after constructing the Client object! It will print out a warning if invoked too late.
</description>
		</method>
		<method name="SetVoiceParticipantChangedCallback">
			<return type="void" />
			<param index="0" name="cb" type="Callable" />
			<description>
 Callback invoked whenever a user in a lobby joins or leaves a voice call.
 The main use case for this is to enable displaying which users are in voice in a lobby even if the current user is not in voice yet, and thus does not have a Call object to bind to.

Where [param cb] signature is:
[codeblock]
func(lobbyId: int, memberId: int, added: bool)
[/codeblock]
</description>
		</method>
		<method name="ShowAudioRoutePicker">
			<return type="bool" />
			<description>
 On iOS devices, show the system audio route picker.
</description>
		</method>
		<method name="StartCall">
			<return type="DiscordppCall" />
			<param index="0" name="channelId" type="int" />
			<description>
 Starts or joins a call in the lobby specified by channelId (For a lobby, simply pass in the lobbyId).
 On iOS, your application is responsible for enabling the appropriate background audio mode in your Info.plist. VoiceBuildPostProcessor in the sample demonstrates how to do this automatically in your Unity build process.
 On macOS, you should set the NSMicrophoneUsageDescription key in your Info.plist.
 Returns null if the user is already in the given voice channel.
</description>
		</method>
		<method name="StartCallWithAudioCallbacks">
			<return type="DiscordppCall" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="receivedCb" type="Callable" />
			<param index="2" name="capturedCb" type="Callable" />
			<description>
 Starts or joins a call in the specified lobby.
 The audio received callback is invoked whenever incoming audio is received in a call. If the developer sets outShouldMute to true during the callback, the audio data will be muted after the callback is invoked, which is useful if the developer is utilizing the incoming audio and playing it through their own audio engine or playback. The audio samples in `data` can be modified in-place for simple DSP effects.
 The audio captured callback is invoked whenever local audio is captured before it is processed and transmitted which may be useful for voice moderation, etc.
 On iOS, your application is responsible for enabling the appropriate background audio mode in your Info.plist. VoiceBuildPostProcessor in the sample demonstrates how to do this automatically in your Unity build process.
 On macOS, you should set the NSMicrophoneUsageDescription key in your Info.plist.
 Returns null if the user is already in the given voice channel.

Where [param receivedCb] signature is:
[codeblock]
func(userId: int, data: int, samplesPerChannel: int, sampleRate: int, channels: int, outShouldMute: bool)
[/codeblock]

Where [param capturedCb] signature is:
[codeblock]
func(data: int, samplesPerChannel: int, sampleRate: int, channels: int)
[/codeblock]
</description>
		</method>
		<method name="StatusToString" qualifiers="static">
			<return type="String" />
			<param index="0" name="type" type="int" enum="DiscordppClientStatus.Enum" />
			<description>
 Converts the Status enum to a string.
</description>
		</method>
		<method name="ThreadToString" qualifiers="static">
			<return type="String" />
			<param index="0" name="type" type="int" enum="DiscordppClientThread.Enum" />
			<description>
 Converts the Thread enum to a string.
</description>
		</method>
		<method name="UnblockUser">
			<return type="void" />
			<param index="0" name="userId" type="int" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Unblocks the target user. Does not restore any old relationship between the users though.
 Fails if the target user is not currently blocked.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="UnlinkChannelFromLobby">
			<return type="void" />
			<param index="0" name="lobbyId" type="int" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Removes any existing channel link from the specified lobby.
 See the docs on LobbyHandle for more information. A lobby can be unlinked by any user with the LobbyMemberFlags::CanLinkLobby flag, they do not need to have any permissions on the Discord channel in order to sever the in-game link.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="UnmergeIntoProvisionalAccount">
			<return type="void" />
			<param index="0" name="applicationId" type="int" />
			<param index="1" name="externalAuthType" type="int" enum="DiscordppAuthenticationExternalAuthType.Enum" />
			<param index="2" name="externalAuthToken" type="String" />
			<param index="3" name="callback" type="Callable" />
			<description>
 This function is used to unlink/unmerge a external identity from a Discord account. This is useful if the user wants to unlink their external identity from their Discord account and create a new provisional account for that identity. This will invalidate all access/refresh tokens for the user and they cannot be used again.
 This function should be used with the Client::GetProvisionalToken function to get a provisional token for the newly created provisional account.
 NOTE: This function only works for public clients. Public clients are ones that do not have a backend server or their own concept of user accounts and simply rely on a separate system for authentication like Steam/Epic.
 When first testing the SDK, it can be a lot easier to use a public client to get a proof of concept going, and change it to a confidential client later. You can toggle that setting on the OAuth2 page for your application in the Discord developer portal, https://discord.com/developers/applications

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="UpdateProvisionalAccountDisplayName">
			<return type="void" />
			<param index="0" name="name" type="String" />
			<param index="1" name="callback" type="Callable" />
			<description>
 Updates the display name of a provisional account to the specified name.
 This should generally be invoked whenever the SDK starts and whenever a provisional account changes their name, since the auto-generated name for provisional accounts is just a random string.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="UpdateRichPresence">
			<return type="void" />
			<param index="0" name="activity" type="DiscordppActivity" />
			<param index="1" name="cb" type="Callable" />
			<description>
 Updates the rich presence for the current user.
 You should use rich presence so that other users on Discord know this user is playing a game and you can include some hints of what they are playing such as a character name or map name. Rich presence also enables Discord game invites to work too!
 Note: On Desktop, rich presence can be set before calling Client::Connect, but it will be cleared if the Client connects. When Client is not connected, this sets the rich presence in the current user's Discord client when available.
 See the docs on the Activity struct for more details.
 Note: The Activity object here is a partial object, fields such as name, and applicationId cannot be set and will be overwritten by the SDK. See https://discord.com/developers/docs/rich-presence/using-with-the-game-sdk#partial-activity-struct for more information.

Where [param cb] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
		<method name="UpdateToken">
			<return type="void" />
			<param index="0" name="tokenType" type="int" enum="DiscordppAuthorizationTokenType.Enum" />
			<param index="1" name="token" type="String" />
			<param index="2" name="callback" type="Callable" />
			<description>
 Asynchronously sets a new auth token for this client to use.
 If your client is already connected, this function *may* trigger a reconnect. If your client is not connected, this function will only update the auth token, and so you must invoke Client::Connect as well. You should wait for the given callback function to be invoked though so that the next Client::Connect attempt uses the updated token.

Where [param callback] signature is:
[codeblock]
func(result: DiscordppClientResult)
[/codeblock]
</description>
		</method>
	</methods>
</class>
